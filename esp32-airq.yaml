esphome:
  name: esp32-airq
esp32:
  board: esp32dev
  

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
    platform: esphome
globals:
  - id: iaq_index
    type: int
    restore_value: no
    initial_value: "0"


wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32-airq"
    password: "f4OfAgm9QSq2"

esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

bluetooth_proxy:
  active: true


captive_portal:



uart:

  - id: uart_1
    #tx_pin: D1
    rx_pin: GPIO 18
    baud_rate: 9600
  - id: uart_2
    tx_pin: GPIO 17
    rx_pin: GPIO 16
    baud_rate: 9600

i2c:
  sda: GPIO 22
  scl: GPIO 23
  frequency: 400kHz
#  scan: true
  
 
time:
  - platform: homeassistant
    id: esptime

    on_time:
      - seconds: 59
        minutes: 59
        hours: 23
        then:
          - switch.toggle: restart_sw    


sensor:
  - platform: internal_temperature
    name: "airq32 IntT" 

  - platform: wifi_signal
    name: "airq32 wifi signal"
    update_interval: 60s

  - platform: wifi_signal
    name: "airq32 RSSI"
    update_interval: 10min
    unit_of_measurement: '%'
    accuracy_decimals: 0
    filters:
    - lambda: return map(x, -100, -20, 0, 100);

  - platform: senseair
    id: coo_2
    co2:
      id: co_2
      name: "airq32  CO2 Value"
      filters:
        - skip_initial: 1
      on_value:
        - if:
            condition:
                and:
                  - lambda: 'return id(co_2).state < 800;'
                  - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 30%
                  effect: none
                  red: 0%
                  green: 100%
                  blue: 0%
        - if:
            condition:
                and:
                  - lambda: 'return id(co_2).state >= 800 && id(co_2).state < 1000;'
                  - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 30%
                  effect: none
                  red: 20%
                  green: 100%
                  blue: 0%
        - if:
            condition:
                and:
                  - lambda: 'return id(co_2).state >= 1000 && id(co_2).state < 1200;'
                  - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 30% #!lambda |-
                    #return id(brightness).state / 52;
                  effect: none
                  red: 100%
                  green: 100%
                  blue: 0%
        - if:
            condition:
                and:
                  - lambda: 'return id(co_2).state >= 1200 && id(co_2).state < 1500;'
                  - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 30%
                  effect: none
                  red: 100%
                  green: 50%
                  blue: 0%
        - if:
            condition:
              and:
                - lambda: 'return id(co_2).state >= 1500 && id(co_2).state < 2000;'
                - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 30%
                  effect: none
                  red: 100%
                  green: 0%
                  blue: 0%
        - if:
            condition:
                and:
                  - lambda: 'return id(co_2).state >= 2000 && id(co_2).state < 3000;'
                  - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 30%
                  effect: none
                  red: 60%
                  green: 0%
                  blue: 60%
        - if:
            condition:
              and:
                - lambda: 'return id(co_2).state >= 3000 && id(co_2).state < 10000;'
                - light.is_on: AIRQ32_LED
            then:
              - light.turn_on:
                  id: AIRQ32_LED
                  brightness: 50%
                  effect: pulse
                  red: 100%
                  green: 0%
                  blue: 0%
    update_interval: 40s
    uart_id: uart_2

  - platform: pmsx003
    type: PMSX003
    pm_1_0:
      name: "airq32 <1.0µm"
      filters:
        heartbeat: 30s
    pm_2_5:
      name: "airq32 <2.5µm"
      filters:
        heartbeat: 30s
    pm_10_0:
      name: "airq32 <10.0µm"
      filters:
        heartbeat: 30s
    uart_id: uart_1
    
  - platform: bme280_i2c
    temperature:
      name: "airq32 temp"
      oversampling: 16x
      id: temp
      accuracy_decimals: 1
      filters:
        - offset: -2.6
    pressure:
      name: "airq32 pres"
      oversampling: 16x
      id: press
      accuracy_decimals: 1
      internal: true
    humidity:
      name: "airq32 humidity"
      oversampling: 16x
      accuracy_decimals: 1
      filters:
       - offset: 9.3
      id: hum
    address: 0x76
    update_interval: 60s
    iir_filter: 16x

  - platform: bh1750
    name: "airq32 Illuminance"
    address: 0x23
    id: brightness
    unit_of_measurement: lx
    update_interval: 15s
    on_value:
       - light.turn_on:
          id: oled_c


  - platform: template
    name: airq32 pressure
    id: prsmm
    lambda: return id(press).state*0.750063755419211 ;
    update_interval: 60s
    unit_of_measurement: 'ммРтСт'
    icon: 'mdi:thermometer-lines'
    accuracy_decimals: 1

  - platform: uptime
    name: Uptime Sensor
    id: uptime_sensor
    internal: true
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();
              
  - platform: adc
    pin: GPIO33
    name: "Batt18650"
    id: voltage18
    attenuation: auto
    device_class: "voltage"
    state_class: "measurement"
    accuracy_decimals: 1
    update_interval: 60s
    filters:
      - multiply: 1.53
      - median

  - platform: template
    device_class: "battery"
    state_class: "measurement"
    name: Batt %
    lambda: return id(voltage18).state/4.2*100 ;

text_sensor:
  - platform: template
    update_interval: 120s
    name: IAQ
    icon: "mdi:air-filter"

    lambda: |-
      id(iaq_index) = 0;
      //*
      //* Transform indoor humidity values to IAQ points according to Indoor Air Quality UK: 
      // * http://www.iaquk.org.uk/
      //*/
      if (id(hum).state < 10 or id(hum).state > 90) {
        id(iaq_index) += 1;
      }
      else if (id(hum).state < 20 or id(hum).state > 80) {
        id(iaq_index) += 2;
      }
      else if (id(hum).state < 30 or id(hum).state > 70) {
        id(iaq_index) += 3;
      }
      else if (id(hum).state < 40 or id(hum).state > 60) {
        id(iaq_index) += 4;
      }
      else if (id(hum).state >= 40 and id(hum).state <= 60) {
        id(iaq_index) += 5;
      }
      /*
       * Transform eCO2 values to IAQ points according to Indoor Air Quality UK: 
       * http://www.iaquk.org.uk/
       */
      if (id(co_2).state <= 600) {
        id(iaq_index) += 5;
      }
      else if (id(co_2).state <= 800) {
        id(iaq_index) += 4;
      }
      else if (id(co_2).state <= 1500) {
        id(iaq_index) += 3;
      }
      else if (id(co_2).state <= 1800) {
        id(iaq_index) += 2;
      }
      else if (id(co_2).state > 1800) {
        id(iaq_index) += 1;
      }
      /*
       * Transform IAQ index to human readable text according to Indoor Air Quality UK: 
       * http://www.iaquk.org.uk/
       */
      ESP_LOGD("main", "Current IAQ index %d", id(iaq_index));
      if (id(iaq_index) <= 6) {
        return {"Невыносимо"};
      }
      else if (id(iaq_index) <= 9) {
        return {"Плохо"};
      }
      else if (id(iaq_index) <= 12) {
        return {"Средне"};
      }
      else if (id(iaq_index) <= 14) {
        return {"Хорошо"};
      }
      else if (id(iaq_index) > 14) {
        return {"Прекрасно"};
      }
      return {};
  - platform: template
    update_interval: 120s
    icon: "mdi:chemical-weapon"
    name: IAQ Index
    lambda: |-
      id(iaq_index) = 0;
      if (id(hum).state < 10 or id(hum).state > 90) {
        id(iaq_index) += 1;
      }
      else if (id(hum).state < 20 or id(hum).state > 80) {
        id(iaq_index) += 2;
      }
      else if (id(hum).state < 30 or id(hum).state > 70) {
        id(iaq_index) += 3;
      }
      else if (id(hum).state < 40 or id(hum).state > 60) {
        id(iaq_index) += 4;
      }
      else if (id(hum).state >= 40 and id(hum).state <= 60) {
        id(iaq_index) += 5;
      }
      if (id(co_2).state <= 600) {
        id(iaq_index) += 5;
      }
      else if (id(co_2).state <= 800) {
        id(iaq_index) += 4;
      }
      else if (id(co_2).state <= 1500) {
        id(iaq_index) += 3;
      }
      else if (id(co_2).state <= 1800) {
        id(iaq_index) += 2;
      }
      else if (id(co_2).state > 1800) {
        id(iaq_index) += 1;
      }
      if (id(iaq_index) == 1) {
        return {"10"};
      }
      else if (id(iaq_index) == 2) {
        return {"20"};
      }
      else if (id(iaq_index) == 3) {
        return {"30"};
      }
      else if (id(iaq_index) == 4) {
        return {"40"};
      }
      else if (id(iaq_index) == 5) {
        return {"50"};
      }
      else if (id(iaq_index) == 6) {
        return {"60"};
      }
      else if (id(iaq_index) == 7) {
        return {"70"};
      }
      else if (id(iaq_index) == 8) {
        return {"80"};
      }
      else if (id(iaq_index) == 9) {
        return {"90"};
      }
      else if (id(iaq_index) == 10) {
        return {"100"};
      }
      else if (id(iaq_index) == 11) {
        return {"110"};
      }
      else if (id(iaq_index) == 12) {
        return {"120"};
      }
      else if (id(iaq_index) == 13) {
        return {"130"};
      }
      else if (id(iaq_index) == 14) {
        return {"140"};
      }
      else if (id(iaq_index) > 14) {
        return {"150"};
      }
      return {};
  - platform: template
    name: airq32 Uptime
    id: uptime_human
    icon: mdi:clock-start
font:
  - file: 'cristall.ttf'
    id: font1
    size: 12

  - file: 'cristall.ttf'
    id: font2
    size: 24

  - file: 'cristall.ttf'
    id: font3
    size: 14
  


display:
  - platform: ssd1306_i2c
    id: OLED
    model: "SH1106 128x64"
    address: 0x3C
    #brightness: 100%
    #contrast: 90%
    rotation: 90
    lambda: |-
      // Print time in HH:MM format
      it.strftime(0, 10, id(font1), TextAlign::BASELINE_LEFT, "%d.%m.%Y", id(esptime).now());
      // Print time in HH:MM format
      it.strftime(0, 35, id(font2), TextAlign::BASELINE_LEFT, "%H:%M", id(esptime).now());
      // PRINT TEMP FROM BME280
      if (id(temp).has_state()) {
        it.printf(0, 50, id(font3), TextAlign::TOP_LEFT , "T: %.1fC", id(temp).state);
      }
      // PRINT HUM FROM BME280
      if (id(hum).has_state()) {
        it.printf(0, 70, id(font3), TextAlign::TOP_LEFT , "H: %.1f%%", id(hum).state);
      }
      // PRINT pressure FROM BME280
      if (id(prsmm).has_state()) {
        it.printf(0, 90, id(font3), TextAlign::TOP_LEFT , "D: %.0fmm", id(prsmm).state);  
      }
      // PRINT CO2 FROM SENSEAIR S8
      if (id(co_2).has_state()) {
        it.printf(0, 110, id(font3), TextAlign::TOP_LEFT , "C: %.0fppm", id(co_2).state);
      } 
#      else: 
 #       id(OLED).set_contrast: 0
 #       id(OLED).setup();

light:
  - platform: status_led
    name: "Status Led"
    internal: true
    pin: 
      number: GPIO2
      inverted: true

  - platform: monochromatic
    name: "OLED Brightness%"
    internal: true
    id: oled_c
    output: oled_bc

  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO19
    num_leds: 1
    rmt_channel: 0
    chipset: ws2812
    name: "AIRQ32 LED"
    id: AIRQ32_LED
    #color_correct: [90%,90%,90%]
    default_transition_length: 1s
    effects:
      - addressable_color_wipe:
      - addressable_color_wipe:
          name: Color Wipe Effect With Custom Values
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
          
      # Use default parameters:
      - random:
      # Customize parameters
      - random:
          name: "My Slow Random Effect"
          transition_length: 30s
          update_interval: 30s
      - random:
          name: "My Fast Random Effect"
          transition_length: 4s
          update_interval: 5s
      - pulse:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.5s
          update_interval: 0.5s
      - pulse:
          name: "Slow Pulse"
          transition_length: 1s      # defaults to 1s
          update_interval: 2s
switch:
  - platform: gpio
    pin: 
      number: GPIO27
    id: pms_set
    name: "airq32 Start measuring"
  - platform: template
    name: "sens back"
    optimistic: true
    on_turn_on:
      - senseair.background_calibration: coo_2
      - delay: 60s
      - senseair.background_calibration_result: coo_2

  - platform: template
    name: "airq32 sens abc"
    optimistic: true
    restore_mode: ALWAYS_ON
    on_turn_on:
      - senseair.abc_enable: coo_2
    on_turn_off:
      - senseair.abc_disable: coo_2
      
  - platform: template
    name: "airq32 sens back result"
    optimistic: true
    on_turn_on:
      - senseair.background_calibration_result: coo_2
      
  - platform: restart
    name: "airq32 restart"
    id: restart_sw


interval:
  - interval: 600s
    then:
      - switch.turn_on: pms_set
      - delay: 31s
      - switch.turn_off: pms_set

output:
  - platform: template
    id: oled_bc
    type: float
    min_power: 0.45
    max_power: 1
    write_action:
      then:
        - lambda: |-
             id(OLED).set_contrast(id(brightness).state/100);
    
